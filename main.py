import numpy as np
import pickle
from mlxtend.data import loadlocal_mnist


np.random.seed(1)                   # заставим numpy выдавать одинаковые набор случайных чисел для каждого запуска программы
np.set_printoptions(suppress=True)  # выводить числа в формате 0.123 а не 1.23e-1


# Загрузка датасета:

# В `X` находятся изображения для обучения, а в `y` значения соответственно
# `X.shape` == (60000, 784)   # изображения имеют размер 28x28 pix => 28*28=784
# `y.shape` == (60000,)       # каждое значение это число от 0 до 9 то что изображено на соответствующем изображении 
X, y = loadlocal_mnist(
        images_path="<путь до>/train-images-idx3-ubyte", 
        labels_path="<путь до>/train-labels-idx1-ubyte")

# В `Xt` находятся изображения для тестирования, а в `yt` значения соответственно
# `Xt.shape` == (10000, 784)   # изображения имеют размер 28x28 pix => 28*28=784
# `yt.shape` == (10000,)       # каждое значение это число от 0 до 9 то что изображено на соответствующем изображении 
Xt, yt = loadlocal_mnist(
        images_path="<путь до>/t10-images-idx3-ubyte", 
        labels_path="<путь до>/t10-labels-idx1-ubyte")

# Параметры:

lr = 0.01    # значени на которое будет домножаться дельта на каждом шаге
batch = 60   # кол-во изображений использованное для обучения на каждом шаге

# Объявляем веса:

W1 = <...> # инициализация случайными числами с равномерным распределением (uniform distribution) в диапазоне от -0.05 до 0.05
W2 = <...> # тоже самое
b1 = np.zeros((16,))
b2 = np.zeros((10,))

# Объявляем дельты

<...>

# Обучение:

for epoch in range(0, 10): # это кол-во эпох, параметр который можно менять. Если видно что прогресс есть, но нужно больше итераций 
    # нужно сделать цикл на каждой итерации которого последовательно выбирать `batch` примеров из `X`
    # например индексы для 60 элементов в батче:
    #   итерация 1 - от 0 до 59
    #   итерация 2 - от 60 до 119
    #   итерация 3 - от 120 до 179 
    #   и т.д.
    for <...>:
        # Forward 
        # Backward
        # Вычисление дельт для `W1`, `W2`, `b1` и `b2`
        # Вычитание дельт из `W1`, `W2`, `b1` и `b2`
        # Подсчет точности:
        #   - берем  код из прошлой лабы о подсчете точности (используя `Xt` и `yt`) с матрицами параметров `W1` и `W2` и байасами `b1` и `b2`


